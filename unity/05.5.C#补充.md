# .Net
![Alt text](image-101.png)

## 跨平台
* Mono

* IL2CPP
    ```c#
    #region 知识点一 —— 安装Unity IL2CPP打包工具
    //在Unityhub中下载 IL2CPP打包相关工具
    #endregion

    #region 知识点二 —— IL2CPP打包存在的问题——类型裁剪
    //IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，
    //以达到减小发布后包的尺寸的目的。
    //然而在实际使用过程中，很多类型有可能会被意外剪裁掉，
    //造成运行时抛出找不到某个类型的异常。
    //特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题

    //解决方案：
    //1.IL2CPP处理模式时，将PlayerSetting->Other Setting->Managed Stripping Level(代码剥离)设置为Low
    // Disable:Mono模式下才能设置为不删除任何代码
    // Low:默认低级别，保守的删除代码，删除大多数无法访问的代码，同时也最大程度减少剥离实际使用的代码的可能性
    // Medium:中等级别，不如低级别剥离谨慎，也不会达到高级别的极端
    // Hight:高级别，尽可能多的删除无法访问的代码，有限优化尺寸减小。如果选择该模式一般需要配合link.xml使用

    //2.通过Unity提供的link.xml方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的
    //  在Unity工程的Assets目录中（或其任何子目录中）建立一个叫link.xml的XML文件
    #endregion

    #region 知识点三 —— IL2CPP打包存在的问题——泛型问题
    //我们上节课提到了IL2CPP和Mono最大的区别是 不能在运行时动态生成代码和类型
    //就是说 泛型相关的内容，如果你在打包生成前没有把之后想要使用的泛型类型显示使用一次
    //那么之后如果使用没有被编译的类型，就会出现找不到类型的报错

    //举例：List<A>和List<B>中A和B是我们自定义的类，
    //我能必须在代码中显示的调用过，IL2CPP才能保留List<A>和List<B>两个类型。
    //如果在热更新时我们调用List<C>，但是它之前并没有在代码中显示调用过，
    //那么这时就会出现报错等问题。主要就是因为JIT和AOT两个编译模式的不同造成的
    List<A> list = new List<A>();
    List<B> list2 = new List<B>();

    //解决方案：
    //泛型类：声明一个类，然后在这个类中声明一些public的泛型类变量
    //泛型方法：随便写一个静态方法，在将这个泛型方法在其中调用一下。这个静态方法无需被调用
    //这样做的目的其实就是在预言编译之前让IL2CPP知道我们需要使用这个内容
    #endregion

    #region 总结
    //对于我们目前开发的新项目
    //都建议大家使用IL2CPP脚本后处理模式来进行打包
    //主要原因是因为它的效率相对Mono较高，同时由于它自带裁剪功能，包的大小也会小一些
    //但是如果在测试时出现 类型无法识别等问题
    //需要用到我们这节课学习的知识点来解决这些问题
    #endregion
    ```
    * 示例
    ```c#
    namespace MyGame
    {
        public class Test
        {

        }

        public class A
        { }

    }

    public class A
    {

    }

    public class B
    {

    }

    public class C
    {

    }

    public class IL2CPP_Info
    {
        public List<A> list;
        public List<B> list2;
        public List<C> list3;

        public Dictionary<int, string> dic = new Dictionary<int, string>();

        public void Test<T>(T info)
        {

        }

        public static void Test()
        {
            IL2CPP_Info info = new IL2CPP_Info();
            info.Test<int>(1);
            info.Test<float>(1);
            info.Test<bool>(true);
        }

    }
    ```
    * link.xml
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>

    <!--保存整个程序集-->
    <assembly fullname="UnityEngine" preserve="all"/>
    <!--没有“preserve”属性，也没有指定类型意味着保留所有-->
    <assembly fullname="UnityEngine"/>

    <!--完全限定程序集名称-->
    <assembly fullname="Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null">
    <type fullname="Assembly-CSharp.Foo" preserve="all"/>
    </assembly>

    <!--在程序集中保留类型和成员-->
    <assembly fullname="Assembly-CSharp">
    <!--保留整个类型-->
    <type fullname="MyGame.A" preserve="all"/>
    <!--没有“保留”属性，也没有指定成员 意味着保留所有成员-->
    <type fullname="MyGame.B"/>
    <!--保留类型上的所有字段-->
    <type fullname="MyGame.C" preserve="fields"/>
    <!--保留类型上的所有方法-->
    <type fullname="MyGame.D" preserve="methods"/>
    <!--只保留类型-->
    <type fullname="MyGame.E" preserve="nothing"/>
    <!--仅保留类型的特定成员-->
    <type fullname="MyGame.F">
        <!--类型和名称保留-->
        <field signature="System.Int32 field1" />
        <!--按名称而不是签名保留字段-->
        <field name="field2" />
        <!--方法-->
        <method signature="System.Void Method1()" />
        <!--保留带有参数的方法-->
        <method signature="System.Void Method2(System.Int32,System.String)" />
        <!--按名称保留方法-->
        <method name="Method3" />

        <!--属性-->
        <!--保留属性-->
        <property signature="System.Int32 Property1" />
        <property signature="System.Int32 Property2" accessors="all" />
        <!--保留属性、其支持字段（如果存在）和getter方法-->
        <property signature="System.Int32 Property3" accessors="get" />
        <!--保留属性、其支持字段（如果存在）和setter方法-->
        <property signature="System.Int32 Property4" accessors="set" />
        <!--按名称保留属性-->
        <property name="Property5" />

        <!--事件-->
        <!--保存事件及其支持字段（如果存在），添加和删除方法-->
        <event signature="System.EventHandler Event1" />
        <!--根据名字保留事件-->
        <event name="Event2" />
    </type>

    <!--泛型相关保留-->
    <type fullname="MyGame.G`1">
        <!--保留带有泛型的字段-->
        <field signature="System.Collections.Generic.List`1&lt;System.Int32&gt; field1" />
        <field signature="System.Collections.Generic.List`1&lt;T&gt; field2" />

        <!--保留带有泛型的方法-->
        <method signature="System.Void Method1(System.Collections.Generic.List`1&lt;System.Int32&gt;)" />
        <!--保留带有泛型的事件-->
        <event signature="System.EventHandler`1&lt;System.EventArgs&gt; Event1" />
    </type>


    <!--如果使用类型，则保留该类型的所有字段。如果类型不是用过的话会被移除-->
    <type fullname="MyGame.I" preserve="fields" required="0"/>

    <!--如果使用某个类型，则保留该类型的所有方法。如果未使用该类型，则会将其删除-->
    <type fullname="MyGame.J" preserve="methods" required="0"/>

    <!--保留命名空间中的所有类型-->
    <type fullname="MyGame.SomeNamespace*" />

    <!--保留名称中带有公共前缀的所有类型-->
    <type fullname="Prefix*" />

    </assembly>



    </linker>
    ```
# C#版本与Unity关系
```c#
#region 知识点一 各Unity版本支持的C#版本
//Unity 2021.2 —— C# 9
//Unity 2020.3 —— C# 8
//Unity 2019.4 —— C# 7.3
//Unity 2017   —— C# 6
//Unity 5.5    —— C# 4

//更多信息可以在Untiy官网说明查看
//https://docs.unity3d.com/2020.3/Documentation/Manual/CSharpCompiler.html
#endregion

#region 知识点二 为什么不同Unity版本支持的C#版本不同？
//之所以不同Unity版本支持的C#版本不同
//主要是不同Unity版本 使用的 C#编译器和脚本运行时版本不同

//比如：Unity2020.3 使用的脚本运行时版本等效于.Net 4.6，编译器为Roslyn（罗斯林编译器）
//所以随着Unity的更新，它一般会采用较新的 编译器和运行时版本
//新版本的脚本运行时将为Unity带来了大量的新版C#功能和.NET的功能
//也就意味着它可以支持更高版本的C#
#endregion

#region 知识点三 不同版本的C#对于我们来说有什么意义？
//我们可以根据不同Unity支持的对应C#版本
//来判断我们是否可以使用C#各版本中的一些新功能用来编程
//虽然即使我们没有掌握这些功能也能正常进行开发
//但是往往新功能可以让我们写出更简单明了的代码
//可以节约代码量
#endregion

#region 知识点四 Unity的.Net API兼容级别
//在PlayerSetting->Other Setting->Api Compatibility Level中
//我们可以设置.Net API的兼容级别
//主要有两种选择
//.Net 4.x（特殊需求时）:
//具备较为完整的.Net API，甚至包含了一些无法跨平台的API
//如果你的应用主要针对Windows平台，并且会使用到.Net Standard 2.0中没有的功能时
//会选择使用它

//.Net Standard 2.0（建议使用）:
//是一个.Net标准API集合，相对.Net 4.x包含更少的内容，可以减小最终可执行文件大小
//它具有更好的跨平台支持

//.Net Standard 2.0 配置文件大小是.Net 4.x配置文件的一半
//所以我们尽量使用.Net Standard 2.0
#endregion

#region 总结
//由于新版本Unity会同时更新
//Scripting Runtime(脚本运行时)和 C#编译器的版本
//所以随着Unity版本的提升
//我们能够使用到的C#的新功能和新特性也会增加
//我们要大概了解自己正在使用的Unity版本能够支持的C#版本
//这样在开发时我们就能使用一些对应版本的新功能和特性了
//Unity 2021.2 —— C# 9
//Unity 2020.3 —— C# 8
//Unity 2019.4 —— C# 7.3
//Unity 2017   —— C# 6
//Unity 5.5    —— C# 4

//并且，对于.Net API兼容级别的认识是
//正常情况下 我们都会使用.Net Standard
#endregion
```

# c#各版本新功能和语法
## C# 1~4
```c#
public class Test1
{
    public void TestTest()
    {

    }
}

public class Test2
{
    public void TestTest()
    {

    }
}

public class Lesson3 : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        #region 知识点一 最低支持的C#版本
        //只要是Unity 5.5及以上的版本
        //就支持C# 4版本
        #endregion

        #region 知识点二 C# 1~4的功能和语法有哪些？
        //注意：在这里我不会提及所有的内容
        //     主要会提及Unity开发中会用到的一些功能和特性
        //     对于一些不适合在Unity中使用的内容我会省略

        //C# 1 —— 委托、事件（C#进阶套课）
        //C# 2 —— 泛型、匿名方法、迭代器、可空类型（C#进阶套课）
        //C# 3 ——
        //隐式类型、对象集合初始化、Lambda表达式、匿名类型（C#进阶套课）
        //自动实现属性、拓展方法、分部类（C#核心套课）
        //Linq相关的表达式树（以后专门讲）
        //C# 4 ——
        //泛型的协变和逆变（C#进阶套课）
        //命名和可选参数
        //动态类型
        #endregion

        #region 知识点三 补充未讲解全面的内容 命名和可选参数
        //有了命名参数，我们将不用匹配参数在所调用方法中的顺序
        //每个参数可以按照参数名字进行指定
        Test(1, 1.2f, true);
        Test(f: 3.3f, i: 5, b: false);
        Test(b: false, f: 3.4f, i: 3);

        //命名参数可以配合可选参数使用,让我们做到跳过其中的默认参数直接赋值后面的默认参数
        Test2(1, true, "234");
        Test2(1, s: "234");

        //好处：可以让我们更方便的调用函数，少写一些重载函数
        #endregion

        #region 知识点四 补充未讲解的内容 动态类型
        //关键词：dynamic
        //作用：通过dynamic类型标识变量的使用和对其成员的引用绕过编译时类型检查
        //     改为在运行时解析这些操作。
        //     在大多数情况下，dynamic类型和object类型行为类似
        //     任何非Null表达式都可以转换为dynamic类型。
        //     dynamic类型和object类型不同之处在于，
        //     编译器不会对包含类型 dynamic 的表达式的操作进行解析或类型检查
        //     编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作。
        //     在此过程中，dynamic 类型的变量会编译为 object 类型的变量。
        //     因此，dynamic 类型只在编译时存在，在运行时则不存在。

        //注意：1.使用dynamic功能 需要将Unity的.Net API兼容级别切换为.Net 4.x
        //     2.IL2CPP 不支持 C# dynamic 关键字。它需要 JIT 编译，而 IL2CPP 无法实现
        //     3.动态类型是无法自动补全方法的，我们在书写时一定要保证方法的拼写正确性
        //        所以该功能我们只做了解，不建议大家使用

        //举例说明：
        dynamic dyn = 1;
        object obj = 2;

        dyn += 2;

        print(obj.GetType());
        print(dyn.GetType());
        print(dyn);

        object t = new Test1();
        dynamic tmp = t;
        tmp.TestTest();

        //好处：动态类型可以节约代码量，当不确定对象类型，但是确定对象成员时，可以使用动态类型
        //     通过反射处理某些功能时，也可以考虑使用动态类型来替换它
        #endregion

        #region 总结
        //C# 1~4版本中的功能和语法
        //大多数我们已经在C#四部曲中学习完毕
        //命名和可选参数可以帮助我们少写一些重载函数
        //动态类型可以让我们在某些情况下节约代码量
        //但是由于要使用.Net 4.x，并且IL2CPP不支持，所以不建议使用它，但是如果有特殊需求不得不用，那我们只有退而求其次
        #endregion
    }

    public void Test(int i, float f, bool b)
    {

    }

    public void Test2(int i , bool b = true, string s = "123")
    {

    }

}

```