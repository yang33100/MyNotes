## Nim

给定N堆物品,第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。问先手是否必胜。
先手必胜 ⇔ A1 ⊕ A2 ⊕ A3 ⊕ ... ⊕ An ≠ 0 

## Bash

有1堆石子，总个数是n.两名玩家轮流在石子堆中拿石子，每次至少取1个，至多取m个。取走最后一个石子的玩家为胜者。判定先手和后手谁胜。
先手必胜 ⇔ (m+1) ∤ n 

## Wythoff

有两堆石子，石子数可以不同(a,b)。两人轮流取石子，每次可以在一堆中取，或者从两堆中取走相同个数的石子，数量不限.取走最后一个石头的人获胜。判定先手是否必胜。

α = (sqrt(5) + 1) / 2 

先手必败 ⇔  fabs(a-b) * α == a

## Fibonacci

有1堆石子,总个数是n(n≥2)。游戏双方轮流取石子，规则如下：先手不能在第一次把所有的石子取完，至少取 1 颗；之后每次可以取的石子数至少为 1 ，至多为对手刚取的石子数的 2 倍。取走最后一个石子的人为赢家，求必败态。

先手必败 ⇔ n为斐波那契数

## SG函数

对于游戏 X ，它可以拆分成若干个子游戏x1,x2,...,xn

那么，SG(X) = SG (xi) 异或和

```cpp
给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。
int sg(int x)
{
    if(f[x]!=-1) return f[x];

    unordered_set<int> S;
    int res;
    //此for循环为修改位置，即递归可到达状态
    for(int i=0;i<x;i++)
    {
        for(int j=0;j<x;j++)
        {   
            res=0;
            res^=sg(i);
            res^=sg(j);
            S.insert(res);
        }
    }
    for(int i=0;;i++)
        if(!S.count(i))
            return f[x]=i;
}
int main()
{
    memset(f,-1,sizeof f);
    cin>>n;
    int res=0;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        res^=sg(x);
    }

    if(res) puts("Yes");
    else puts("No");

}
```

## anti-SG

有n堆石子，两个人可以从任意一堆石子中拿任意多个石子，不能不拿，拿走最后一个石子的人“失败”，求必胜策略

先手必胜 ⇔ 当且仅当满足下面两种情况的一种：

（1）任意堆的石子数都为1且游戏的SG值为0

（2）存在堆的石子数大于1且游戏的SG值不为0
